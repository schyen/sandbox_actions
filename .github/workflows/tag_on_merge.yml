name: Bump version in PR and create tag

on:
  pull_request:
    types: [opened, reopened, edited, labeled, unlabeled, synchronize]
  workflow_dispatch:
    inputs:
      version_level:
        description: "Manual bump level"
        required: false
        default: patch
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  contents: write

jobs:
  bump_and_tag:
    if: ${{ github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    env:
      # Optional: set secrets.PUSH_TOKEN (personal access token with repo scope) if your org blocks GITHUB_TOKEN writes
      PUSH_TOKEN: ${{ secrets.PUSH_TOKEN || '' }}
      GITHUB_REPOSITORY: ${{ github.repository }}
      PR_BRANCH: ${{ github.head_ref }}
    steps:
      - name: Checkout PR branch (head)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      - name: Ensure git remote uses token if provided
        shell: bash
        run: |
          if [ -n "${PUSH_TOKEN}" ]; then
            echo "Using PUSH_TOKEN for pushes"
            git remote set-url origin https://x-access-token:${PUSH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git
          else
            echo "Using default runner auth (GITHUB_TOKEN)"
          fi

      - name: Fetch tags from origin
        run: git fetch --tags --force

      - name: Get latest tag
        id: get_latest
        run: |
          latest=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $latest"
          echo "latest_tag=$latest" >> "$GITHUB_OUTPUT"

      - name: Determine initial bump level and candidate tag
        id: determine
        env:
          PR_LABELS: ${{ toJson(github.event.pull_request.labels) }}
          INPUT_LEVEL: ${{ github.event.inputs.version_level }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          latest="${{ steps.get_latest.outputs.latest_tag }}"
          echo "Latest tag: $latest"
          level=""
          if [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            level="$INPUT_LEVEL"
          else
            if echo "$PR_LABELS" | grep -iq '"name":"major"'; then
              level="major"
            elif echo "$PR_LABELS" | grep -iq '"name":"minor"'; then
              level="minor"
            else
              level="patch"
            fi
          fi

          IFS='.' read -r major minor patch <<<"${latest#v}"
          case "$level" in
            major) major=$((major + 1)); minor=0; patch=0 ;;
            minor) minor=$((minor + 1)); patch=0 ;;
            *) patch=$((patch + 1)) ;;
          esac

          candidate="v${major}.${minor}.${patch}"
          echo "bump_level=$level" >> "$GITHUB_OUTPUT"
          echo "candidate_tag=$candidate" >> "$GITHUB_OUTPUT"
          echo "Determined candidate: $candidate"

      - name: Reserve unique tag by looping & update setup.py to match
        id: reserve_and_push
        shell: bash
        run: |
          set -euo pipefail

          increment_patch() {
            v="$1"
            v="${v#v}"
            IFS='.' read -r maj min pat <<<"$v"
            pat=$((pat + 1))
            echo "v${maj}.${min}.${pat}"
          }

          branch="${PR_BRANCH}"
          candidate="${{ steps.determine.outputs.candidate_tag }}"

          while true; do
            echo "Checking remote for tag: $candidate"
            git fetch --tags --force

            # Check remote for existence of the candidate tag
            if git ls-remote --tags origin "$candidate" | grep -q "refs/tags/$candidate"; then
              echo "Tag $candidate already exists on remote â€” incrementing patch and trying again"
              candidate=$(increment_patch "$candidate")
              continue
            fi

            clean="${candidate#v}"
            echo "Updating setup.py to version $clean"

            # Replace only the numeric version portion while preserving surrounding quotes
            # This matches your setup.py format: version="1.0.1"
            sed -i -E "s/(version\s*=\s*['\"])[0-9]+\.[0-9]+\.[0-9]+(['\"])/\1$clean\2/" setup.py

            # If no change (already that version), we'll still attempt to tag current HEAD.
            if git diff --quiet; then
              echo "No changes in setup.py (already set to $clean)"
            else
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git add setup.py
              git commit -m "chore: bump version to ${candidate}" || true
              echo "Pushing commit to PR branch ${branch}"
              git push origin "HEAD:${branch}"
            fi

            # create tag locally (delete local if exists) and push to origin
            if git rev-parse --verify --quiet "$candidate" >/dev/null; then
              git tag -d "$candidate" || true
            fi
            git tag -a "$candidate" -m "Release $candidate"

            echo "Pushing tag $candidate to origin"
            if git push origin "$candidate"; then
              echo "Successfully pushed tag $candidate"
              echo "final_tag=$candidate" >> "$GITHUB_OUTPUT"
              echo "final_version=${candidate#v}" >> "$GITHUB_OUTPUT"
              break
            else
              echo "Tag push failed (race or remote created tag meanwhile). Deleting local tag and retrying with incremented patch."
              git tag -d "$candidate" || true
              candidate=$(increment_patch "$candidate")
              # loop will try again: check existence -> update setup.py (new commit) -> push -> try tag
            fi
          done

      - name: Output result
        run: |
          echo "Version set in PR: ${{ steps.reserve_and_push.outputs.final_version }}"
          echo "Tag created: ${{ steps.reserve_and_push.outputs.final_tag }}"
